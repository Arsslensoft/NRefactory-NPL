//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from E:\Research\NRefactory\NRefactory\ICSharpCode.NRefactory.Rava\Parser\RSharpPreprocessorParser.g4 by ANTLR 4.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace ICSharpCode.NRefactory.Rava.Parser {
 using System.Linq; 
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.3")]
[System.CLSCompliant(false)]
public partial class RSharpPreprocessorParser : Parser {
	public const int
		BITWISE_OR=144, THROW=85, INTEGER_LITERAL=116, HEX_INTEGER_LITERAL=117, 
		STATIC=79, MINUS=139, CONDITIONAL_SYMBOL=203, INTERR=151, OP_PTR=158, 
		OPEN_BRACE=128, LITERAL_ACCESS=115, PRAGMA=201, ERROR=197, OP_RIGHT_ROTATE_ASSIGNMENT=178, 
		ELIF=194, BANG=146, OCT_INTEGER_LITERAL=119, WHERE=100, OP_DIV_ASSIGNMENT=166, 
		AS=11, MIXIN=57, DELIMITED_DOC_COMMENT=3, INTO=110, OP_LEFT_ROTATE=172, 
		SET=75, SIZEOF=77, CLOSE_BRACKET=131, FOREACH=38, DEFINE=192, INTERRUPT=50, 
		GROUP=109, CLOSE_BRACE=129, OP_LEFT_SHIFT_ASSIGNMENT=173, BY=105, PROTECTED=66, 
		LONG=52, SUPERSEDE=84, YIELD=102, CONTINUE=22, DIV=141, REF=70, REGULAR_STRING_INSIDE=186, 
		OPERATOR=60, STAR=140, PERCENT=142, STRING=80, OPEN_PARENS=132, UNION=91, 
		UNDEF=193, VIRTUAL=96, ULONG=90, ADD=9, FRIEND=48, WHITESPACES=6, CLASS=20, 
		DO=27, FINALLY=35, CHECKED=19, OP_RIGHT_SHIFT_ASSIGNMENT=177, UNCHECKED=92, 
		CONST=21, PACKAGE=54, USHORT=94, DESCENDING=106, FOR=37, OP_NE=160, CARET=145, 
		WARNING=198, IMPLICIT=42, USING=95, OP_ZERO=180, VERBATIUM_DOUBLE_QUOTE_INSIDE=184, 
		SYNC=51, OP_RIGHT_ROTATE=176, READONLY=69, SINGLE_LINE_DOC_COMMENT=2, 
		DIGITS=191, RETURN=72, SEALED=74, DOUBLE_CURLY_CLOSE_INSIDE=206, ASSIGNMENT=148, 
		UNSAFE=93, IDENTIFIER=114, ORDERBY=113, OP_MOD_ASSIGNMENT=167, OP_OR_ASSIGNMENT=169, 
		OPEN_BRACKET=130, OP_LE=161, ENDIF=195, PARTIAL=64, COLON=136, GT=150, 
		SHORT=76, INTERPOLATED_VERBATIUM_STRING_START=127, TYPEOF=88, BOOL=13, 
		FALSE=34, INTERPOLATED_REGULAR_STRING_START=126, REGULAR_CHAR_INSIDE=183, 
		DEFAULT=25, DELEGATE=26, DIRECTIVE_HIDDEN=202, OP_INC=154, JOIN=111, TEXT=205, 
		VLONG=24, WHEN=99, INTERFACE=47, SEMICOLON=137, BREAK=14, BYTE=15, ELSE=29, 
		EXTERN=33, IF=41, ENUM=30, DIRECTIVE_NEW_LINE=204, IN=44, DOT=134, IS=49, 
		OP_RIGHT_SHIFT=175, DIRECTIVE_WHITESPACES=190, CASE=16, OUT=61, REGION=199, 
		GET=39, PUBLIC=67, OP_AND=156, DELIMITED_COMMENT=5, VERBATIUM_INSIDE_STRING=187, 
		FORMAT_STRING=189, GOTO=40, CLOSE_BRACE_INSIDE=188, CHAR=18, BINARY_OPERATOR_LITERAL=121, 
		IMPORT=43, REAL_LITERAL=118, CATCH=17, REMOVE=71, DOUBLE=28, COMMA=135, 
		OPEN_BRACE_INSIDE=182, SELF=83, SBYTE=73, CLOSE_PARENS=133, RAISE=68, 
		SELECT=103, PRIVATE=65, NAMEOF=53, ASCENDING=104, SHARP=7, UINT=89, OP_OR=157, 
		ENDREGION=200, VOLATILE=98, NEW=55, REGULAR_STRING=124, OP_GE=162, OP_LEFT_ROTATE_ASSIGNMENT=174, 
		LT=149, FROM=108, EVENT=31, INLINE=45, TRY=87, OP_XOR_ASSIGNMENT=170, 
		UNARY_OPERATOR_LITERAL=122, EXPLICIT=32, OP_PARITY=179, NULL=56, AMP=143, 
		CHARACTER_LITERAL=123, DOUBLE_CURLY_INSIDE=181, TRUE=86, OBJECT=58, OP_EQ=159, 
		OP_LEFT_SHIFT=171, ARGLIST=10, SWITCH=82, PARAMS=63, VOID=97, STRUCT=81, 
		OP_AND_ASSIGNMENT=168, PLUS=138, FLOAT=36, OP_ADD_ASSIGNMENT=163, ABSTRACT=8, 
		INT=46, SINGLE_LINE_COMMENT=4, DOUBLE_QUOTE_INSIDE=185, LINE=196, BIN_INTEGER_LITERAL=120, 
		VERBATIUM_STRING=125, OP_MULT_ASSIGNMENT=165, ON=59, OP_COALESCING=153, 
		SUPER=12, COMPLEX=23, EQUALS=107, OP_DEC=155, OVERRIDE=62, DOUBLE_COLON=152, 
		ADRESSOF=78, WHILE=101, LET=112, TILDE=147, BYTE_ORDER_MARK=1, OP_SUB_ASSIGNMENT=164;
	public static readonly string[] tokenNames = {
		"<INVALID>", "'\\u00EF\\u00BB\\u00BF'", "SINGLE_LINE_DOC_COMMENT", "DELIMITED_DOC_COMMENT", 
		"SINGLE_LINE_COMMENT", "DELIMITED_COMMENT", "WHITESPACES", "'#'", "'abstract'", 
		"'add'", "'__arglist'", "'as'", "'super'", "'bool'", "'break'", "'byte'", 
		"'case'", "'catch'", "'char'", "'checked'", "'class'", "'const'", "'continue'", 
		"'complex'", "'vlong'", "'default'", "'delegate'", "'do'", "'double'", 
		"'else'", "'enum'", "'event'", "'explicit'", "'extern'", "'false'", "'finally'", 
		"'float'", "'for'", "'foreach'", "'get'", "'goto'", "'if'", "'implicit'", 
		"'import'", "'in'", "'inline'", "'int'", "'interface'", "'friend'", "'is'", 
		"'interrupt'", "'sync'", "'long'", "'nameof'", "'package'", "'new'", "'null'", 
		"'mixin'", "'object'", "'on'", "'operator'", "'out'", "'override'", "'params'", 
		"'partial'", "'private'", "'protected'", "'public'", "'raise'", "'readonly'", 
		"'ref'", "'remove'", "'return'", "'sbyte'", "'sealed'", "'set'", "'short'", 
		"'sizeof'", "'adressof'", "'static'", "'string'", "'struct'", "'switch'", 
		"'self'", "'supersede'", "'throw'", "'true'", "'try'", "'typeof'", "'uint'", 
		"'ulong'", "'union'", "'unchecked'", "'unsafe'", "'ushort'", "'using'", 
		"'virtual'", "'void'", "'volatile'", "'when'", "'where'", "'while'", "'yield'", 
		"'select'", "'ascending'", "'by'", "'descending'", "'equals'", "'from'", 
		"'group'", "'into'", "'join'", "'let'", "'orderby'", "IDENTIFIER", "LITERAL_ACCESS", 
		"INTEGER_LITERAL", "HEX_INTEGER_LITERAL", "REAL_LITERAL", "OCT_INTEGER_LITERAL", 
		"BIN_INTEGER_LITERAL", "BINARY_OPERATOR_LITERAL", "UNARY_OPERATOR_LITERAL", 
		"CHARACTER_LITERAL", "REGULAR_STRING", "VERBATIUM_STRING", "INTERPOLATED_REGULAR_STRING_START", 
		"INTERPOLATED_VERBATIUM_STRING_START", "'{'", "'}'", "'['", "']'", "'('", 
		"')'", "'.'", "','", "':'", "';'", "'+'", "'-'", "'*'", "'/'", "'%'", 
		"'&'", "'|'", "'^'", "'!'", "'~'", "'='", "'<'", "'>'", "'?'", "'::'", 
		"'??'", "'++'", "'--'", "'&&'", "'||'", "'->'", "'=='", "'!='", "'<='", 
		"'>='", "'+='", "'-='", "'*='", "'/='", "'%='", "'&='", "'|='", "'^='", 
		"'<<'", "'<~'", "'<<='", "'<~='", "'>>'", "'~>'", "'>>='", "'~>='", "'?~'", 
		"'?!'", "'{{'", "OPEN_BRACE_INSIDE", "REGULAR_CHAR_INSIDE", "VERBATIUM_DOUBLE_QUOTE_INSIDE", 
		"DOUBLE_QUOTE_INSIDE", "REGULAR_STRING_INSIDE", "VERBATIUM_INSIDE_STRING", 
		"CLOSE_BRACE_INSIDE", "FORMAT_STRING", "DIRECTIVE_WHITESPACES", "DIGITS", 
		"'define'", "'undef'", "'elif'", "'endif'", "'line'", "ERROR", "WARNING", 
		"REGION", "ENDREGION", "PRAGMA", "'hidden'", "CONDITIONAL_SYMBOL", "DIRECTIVE_NEW_LINE", 
		"TEXT", "'}}'"
	};
	public const int
		RULE_preprocessor_directive = 0, RULE_directive_new_line_or_sharp = 1, 
		RULE_preprocessor_expression = 2;
	public static readonly string[] ruleNames = {
		"preprocessor_directive", "directive_new_line_or_sharp", "preprocessor_expression"
	};

	public override string GrammarFileName { get { return "RSharpPreprocessorParser.g4"; } }

	public override string[] TokenNames { get { return tokenNames; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	Stack<bool> conditions = new Stack<bool>(new bool[] { true });
	public HashSet<string> ConditionalSymbols = new HashSet<string>() { "DEBUG" };
	public RSharpPreprocessorParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class Preprocessor_directiveContext : ParserRuleContext {
		public bool value;
		public Preprocessor_directiveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_preprocessor_directive; } }
	 
		public Preprocessor_directiveContext() { }
		public virtual void CopyFrom(Preprocessor_directiveContext context) {
			base.CopyFrom(context);
			this.value = context.value;
		}
	}
	public partial class PreprocessorDiagnosticContext : Preprocessor_directiveContext {
		public ITerminalNode TEXT() { return GetToken(RSharpPreprocessorParser.TEXT, 0); }
		public Directive_new_line_or_sharpContext directive_new_line_or_sharp() {
			return GetRuleContext<Directive_new_line_or_sharpContext>(0);
		}
		public ITerminalNode ERROR() { return GetToken(RSharpPreprocessorParser.ERROR, 0); }
		public ITerminalNode WARNING() { return GetToken(RSharpPreprocessorParser.WARNING, 0); }
		public PreprocessorDiagnosticContext(Preprocessor_directiveContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.EnterPreprocessorDiagnostic(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.ExitPreprocessorDiagnostic(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRSharpPreprocessorParserVisitor<TResult> typedVisitor = visitor as IRSharpPreprocessorParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreprocessorDiagnostic(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PreprocessorRegionContext : Preprocessor_directiveContext {
		public ITerminalNode TEXT() { return GetToken(RSharpPreprocessorParser.TEXT, 0); }
		public Directive_new_line_or_sharpContext directive_new_line_or_sharp() {
			return GetRuleContext<Directive_new_line_or_sharpContext>(0);
		}
		public ITerminalNode ENDREGION() { return GetToken(RSharpPreprocessorParser.ENDREGION, 0); }
		public ITerminalNode REGION() { return GetToken(RSharpPreprocessorParser.REGION, 0); }
		public PreprocessorRegionContext(Preprocessor_directiveContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.EnterPreprocessorRegion(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.ExitPreprocessorRegion(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRSharpPreprocessorParserVisitor<TResult> typedVisitor = visitor as IRSharpPreprocessorParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreprocessorRegion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PreprocessorDeclarationContext : Preprocessor_directiveContext {
		public IToken _CONDITIONAL_SYMBOL;
		public ITerminalNode DEFINE() { return GetToken(RSharpPreprocessorParser.DEFINE, 0); }
		public Directive_new_line_or_sharpContext directive_new_line_or_sharp() {
			return GetRuleContext<Directive_new_line_or_sharpContext>(0);
		}
		public ITerminalNode UNDEF() { return GetToken(RSharpPreprocessorParser.UNDEF, 0); }
		public ITerminalNode CONDITIONAL_SYMBOL() { return GetToken(RSharpPreprocessorParser.CONDITIONAL_SYMBOL, 0); }
		public PreprocessorDeclarationContext(Preprocessor_directiveContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.EnterPreprocessorDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.ExitPreprocessorDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRSharpPreprocessorParserVisitor<TResult> typedVisitor = visitor as IRSharpPreprocessorParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreprocessorDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PreprocessorConditionalContext : Preprocessor_directiveContext {
		public Preprocessor_expressionContext expr;
		public ITerminalNode ELIF() { return GetToken(RSharpPreprocessorParser.ELIF, 0); }
		public ITerminalNode ELSE() { return GetToken(RSharpPreprocessorParser.ELSE, 0); }
		public ITerminalNode IF() { return GetToken(RSharpPreprocessorParser.IF, 0); }
		public Directive_new_line_or_sharpContext directive_new_line_or_sharp() {
			return GetRuleContext<Directive_new_line_or_sharpContext>(0);
		}
		public ITerminalNode ENDIF() { return GetToken(RSharpPreprocessorParser.ENDIF, 0); }
		public Preprocessor_expressionContext preprocessor_expression() {
			return GetRuleContext<Preprocessor_expressionContext>(0);
		}
		public PreprocessorConditionalContext(Preprocessor_directiveContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.EnterPreprocessorConditional(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.ExitPreprocessorConditional(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRSharpPreprocessorParserVisitor<TResult> typedVisitor = visitor as IRSharpPreprocessorParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreprocessorConditional(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PreprocessorPragmaContext : Preprocessor_directiveContext {
		public ITerminalNode TEXT() { return GetToken(RSharpPreprocessorParser.TEXT, 0); }
		public Directive_new_line_or_sharpContext directive_new_line_or_sharp() {
			return GetRuleContext<Directive_new_line_or_sharpContext>(0);
		}
		public ITerminalNode PRAGMA() { return GetToken(RSharpPreprocessorParser.PRAGMA, 0); }
		public PreprocessorPragmaContext(Preprocessor_directiveContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.EnterPreprocessorPragma(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.ExitPreprocessorPragma(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRSharpPreprocessorParserVisitor<TResult> typedVisitor = visitor as IRSharpPreprocessorParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreprocessorPragma(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PreprocessorLineContext : Preprocessor_directiveContext {
		public ITerminalNode LINE() { return GetToken(RSharpPreprocessorParser.LINE, 0); }
		public Directive_new_line_or_sharpContext directive_new_line_or_sharp() {
			return GetRuleContext<Directive_new_line_or_sharpContext>(0);
		}
		public ITerminalNode DIRECTIVE_HIDDEN() { return GetToken(RSharpPreprocessorParser.DIRECTIVE_HIDDEN, 0); }
		public ITerminalNode DIGITS() { return GetToken(RSharpPreprocessorParser.DIGITS, 0); }
		public ITerminalNode STRING() { return GetToken(RSharpPreprocessorParser.STRING, 0); }
		public ITerminalNode DEFAULT() { return GetToken(RSharpPreprocessorParser.DEFAULT, 0); }
		public PreprocessorLineContext(Preprocessor_directiveContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.EnterPreprocessorLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.ExitPreprocessorLine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRSharpPreprocessorParserVisitor<TResult> typedVisitor = visitor as IRSharpPreprocessorParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreprocessorLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Preprocessor_directiveContext preprocessor_directive() {
		Preprocessor_directiveContext _localctx = new Preprocessor_directiveContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_preprocessor_directive);
		int _la;
		try {
			State = 75;
			switch (_input.La(1)) {
			case DEFINE:
				_localctx = new PreprocessorDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 6; Match(DEFINE);
				State = 7; ((PreprocessorDeclarationContext)_localctx)._CONDITIONAL_SYMBOL = Match(CONDITIONAL_SYMBOL);
				State = 8; directive_new_line_or_sharp();
				 ConditionalSymbols.Add((((PreprocessorDeclarationContext)_localctx)._CONDITIONAL_SYMBOL!=null?((PreprocessorDeclarationContext)_localctx)._CONDITIONAL_SYMBOL.Text:null));
					   ((PreprocessorDeclarationContext)_localctx).value =  conditions.All(c => c); 
				}
				break;
			case UNDEF:
				_localctx = new PreprocessorDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 11; Match(UNDEF);
				State = 12; ((PreprocessorDeclarationContext)_localctx)._CONDITIONAL_SYMBOL = Match(CONDITIONAL_SYMBOL);
				State = 13; directive_new_line_or_sharp();
				 ConditionalSymbols.Remove((((PreprocessorDeclarationContext)_localctx)._CONDITIONAL_SYMBOL!=null?((PreprocessorDeclarationContext)_localctx)._CONDITIONAL_SYMBOL.Text:null));
					   ((PreprocessorDeclarationContext)_localctx).value =  conditions.All(c => c); 
				}
				break;
			case IF:
				_localctx = new PreprocessorConditionalContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 16; Match(IF);
				State = 17; ((PreprocessorConditionalContext)_localctx).expr = preprocessor_expression(0);
				State = 18; directive_new_line_or_sharp();
				 ((PreprocessorConditionalContext)_localctx).value =  ((PreprocessorConditionalContext)_localctx).expr.value == "true" && conditions.All(c => c); conditions.Push(((PreprocessorConditionalContext)_localctx).expr.value == "true"); 
				}
				break;
			case ELIF:
				_localctx = new PreprocessorConditionalContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 21; Match(ELIF);
				State = 22; ((PreprocessorConditionalContext)_localctx).expr = preprocessor_expression(0);
				State = 23; directive_new_line_or_sharp();
				 if (!conditions.Peek()) { conditions.Pop(); ((PreprocessorConditionalContext)_localctx).value =  ((PreprocessorConditionalContext)_localctx).expr.value == "true" && conditions.All(c => c);
					     conditions.Push(((PreprocessorConditionalContext)_localctx).expr.value == "true"); } else ((PreprocessorConditionalContext)_localctx).value =  false; 
				}
				break;
			case ELSE:
				_localctx = new PreprocessorConditionalContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 26; Match(ELSE);
				State = 27; directive_new_line_or_sharp();
				 if (!conditions.Peek()) { conditions.Pop(); ((PreprocessorConditionalContext)_localctx).value =  true && conditions.All(c => c); conditions.Push(true); }
					    else ((PreprocessorConditionalContext)_localctx).value =  false; 
				}
				break;
			case ENDIF:
				_localctx = new PreprocessorConditionalContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 30; Match(ENDIF);
				State = 31; directive_new_line_or_sharp();
				 conditions.Pop(); ((PreprocessorConditionalContext)_localctx).value =  conditions.Peek(); 
				}
				break;
			case LINE:
				_localctx = new PreprocessorLineContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 34; Match(LINE);
				State = 41;
				switch (_input.La(1)) {
				case DIGITS:
					{
					State = 35; Match(DIGITS);
					State = 37;
					_la = _input.La(1);
					if (_la==STRING) {
						{
						State = 36; Match(STRING);
						}
					}

					}
					break;
				case DEFAULT:
					{
					State = 39; Match(DEFAULT);
					}
					break;
				case DIRECTIVE_HIDDEN:
					{
					State = 40; Match(DIRECTIVE_HIDDEN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 43; directive_new_line_or_sharp();
				 ((PreprocessorLineContext)_localctx).value =  conditions.All(c => c); 
				}
				break;
			case ERROR:
				_localctx = new PreprocessorDiagnosticContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 46; Match(ERROR);
				State = 47; Match(TEXT);
				State = 48; directive_new_line_or_sharp();
				 ((PreprocessorDiagnosticContext)_localctx).value =  conditions.All(c => c); 
				}
				break;
			case WARNING:
				_localctx = new PreprocessorDiagnosticContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 51; Match(WARNING);
				State = 52; Match(TEXT);
				State = 53; directive_new_line_or_sharp();
				 ((PreprocessorDiagnosticContext)_localctx).value =  conditions.All(c => c); 
				}
				break;
			case REGION:
				_localctx = new PreprocessorRegionContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 56; Match(REGION);
				State = 58;
				_la = _input.La(1);
				if (_la==TEXT) {
					{
					State = 57; Match(TEXT);
					}
				}

				State = 60; directive_new_line_or_sharp();
				 ((PreprocessorRegionContext)_localctx).value =  conditions.All(c => c); 
				}
				break;
			case ENDREGION:
				_localctx = new PreprocessorRegionContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 63; Match(ENDREGION);
				State = 65;
				_la = _input.La(1);
				if (_la==TEXT) {
					{
					State = 64; Match(TEXT);
					}
				}

				State = 67; directive_new_line_or_sharp();
				 ((PreprocessorRegionContext)_localctx).value =  conditions.All(c => c); 
				}
				break;
			case PRAGMA:
				_localctx = new PreprocessorPragmaContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 70; Match(PRAGMA);
				State = 71; Match(TEXT);
				State = 72; directive_new_line_or_sharp();
				 ((PreprocessorPragmaContext)_localctx).value =  conditions.All(c => c); 
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Directive_new_line_or_sharpContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(RSharpPreprocessorParser.Eof, 0); }
		public ITerminalNode DIRECTIVE_NEW_LINE() { return GetToken(RSharpPreprocessorParser.DIRECTIVE_NEW_LINE, 0); }
		public Directive_new_line_or_sharpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_directive_new_line_or_sharp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.EnterDirective_new_line_or_sharp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.ExitDirective_new_line_or_sharp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRSharpPreprocessorParserVisitor<TResult> typedVisitor = visitor as IRSharpPreprocessorParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirective_new_line_or_sharp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Directive_new_line_or_sharpContext directive_new_line_or_sharp() {
		Directive_new_line_or_sharpContext _localctx = new Directive_new_line_or_sharpContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_directive_new_line_or_sharp);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			_la = _input.La(1);
			if ( !(_la==Eof || _la==DIRECTIVE_NEW_LINE) ) {
			_errHandler.RecoverInline(this);
			}
			Consume();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Preprocessor_expressionContext : ParserRuleContext {
		public string value;
		public Preprocessor_expressionContext expr1;
		public Preprocessor_expressionContext expr;
		public IToken _CONDITIONAL_SYMBOL;
		public Preprocessor_expressionContext expr2;
		public ITerminalNode OP_AND() { return GetToken(RSharpPreprocessorParser.OP_AND, 0); }
		public ITerminalNode FALSE() { return GetToken(RSharpPreprocessorParser.FALSE, 0); }
		public ITerminalNode OP_OR() { return GetToken(RSharpPreprocessorParser.OP_OR, 0); }
		public ITerminalNode TRUE() { return GetToken(RSharpPreprocessorParser.TRUE, 0); }
		public ITerminalNode OP_EQ() { return GetToken(RSharpPreprocessorParser.OP_EQ, 0); }
		public Preprocessor_expressionContext preprocessor_expression(int i) {
			return GetRuleContext<Preprocessor_expressionContext>(i);
		}
		public ITerminalNode OPEN_PARENS() { return GetToken(RSharpPreprocessorParser.OPEN_PARENS, 0); }
		public ITerminalNode CONDITIONAL_SYMBOL() { return GetToken(RSharpPreprocessorParser.CONDITIONAL_SYMBOL, 0); }
		public ITerminalNode CLOSE_PARENS() { return GetToken(RSharpPreprocessorParser.CLOSE_PARENS, 0); }
		public ITerminalNode OP_NE() { return GetToken(RSharpPreprocessorParser.OP_NE, 0); }
		public Preprocessor_expressionContext[] preprocessor_expression() {
			return GetRuleContexts<Preprocessor_expressionContext>();
		}
		public ITerminalNode BANG() { return GetToken(RSharpPreprocessorParser.BANG, 0); }
		public Preprocessor_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_preprocessor_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.EnterPreprocessor_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IRSharpPreprocessorParserListener typedListener = listener as IRSharpPreprocessorParserListener;
			if (typedListener != null) typedListener.ExitPreprocessor_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRSharpPreprocessorParserVisitor<TResult> typedVisitor = visitor as IRSharpPreprocessorParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreprocessor_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Preprocessor_expressionContext preprocessor_expression() {
		return preprocessor_expression(0);
	}

	private Preprocessor_expressionContext preprocessor_expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		Preprocessor_expressionContext _localctx = new Preprocessor_expressionContext(_ctx, _parentState);
		Preprocessor_expressionContext _prevctx = _localctx;
		int _startState = 4;
		EnterRecursionRule(_localctx, 4, RULE_preprocessor_expression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 95;
			switch (_input.La(1)) {
			case BANG:
				{
				State = 80; Match(BANG);
				State = 81; _localctx.expr = preprocessor_expression(5);
				 _localctx.value =  _localctx.expr.value == "true" ? "false" : "true"; 
				}
				break;
			case TRUE:
				{
				State = 84; Match(TRUE);
				 _localctx.value =  "true"; 
				}
				break;
			case FALSE:
				{
				State = 86; Match(FALSE);
				 _localctx.value =  "false"; 
				}
				break;
			case CONDITIONAL_SYMBOL:
				{
				State = 88; _localctx._CONDITIONAL_SYMBOL = Match(CONDITIONAL_SYMBOL);
				 _localctx.value =  ConditionalSymbols.Contains((_localctx._CONDITIONAL_SYMBOL!=null?_localctx._CONDITIONAL_SYMBOL.Text:null)) ? "true" : "false"; 
				}
				break;
			case OPEN_PARENS:
				{
				State = 90; Match(OPEN_PARENS);
				State = 91; _localctx.expr = preprocessor_expression(0);
				State = 92; Match(CLOSE_PARENS);
				 _localctx.value =  _localctx.expr.value; 
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 119;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 117;
					switch ( Interpreter.AdaptivePredict(_input,6,_ctx) ) {
					case 1:
						{
						_localctx = new Preprocessor_expressionContext(_parentctx, _parentState);
						_localctx.expr1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_preprocessor_expression);
						State = 97;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 98; Match(OP_EQ);
						State = 99; _localctx.expr2 = preprocessor_expression(5);
						 _localctx.value =  (_localctx.expr1.value == _localctx.expr2.value ? "true" : "false"); 
						}
						break;

					case 2:
						{
						_localctx = new Preprocessor_expressionContext(_parentctx, _parentState);
						_localctx.expr1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_preprocessor_expression);
						State = 102;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 103; Match(OP_NE);
						State = 104; _localctx.expr2 = preprocessor_expression(4);
						 _localctx.value =  (_localctx.expr1.value != _localctx.expr2.value ? "true" : "false"); 
						}
						break;

					case 3:
						{
						_localctx = new Preprocessor_expressionContext(_parentctx, _parentState);
						_localctx.expr1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_preprocessor_expression);
						State = 107;
						if (!(Precpred(_ctx, 2))) throw new FailedPredicateException(this, "Precpred(_ctx, 2)");
						State = 108; Match(OP_AND);
						State = 109; _localctx.expr2 = preprocessor_expression(3);
						 _localctx.value =  (_localctx.expr1.value == "true" && _localctx.expr2.value == "true" ? "true" : "false"); 
						}
						break;

					case 4:
						{
						_localctx = new Preprocessor_expressionContext(_parentctx, _parentState);
						_localctx.expr1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_preprocessor_expression);
						State = 112;
						if (!(Precpred(_ctx, 1))) throw new FailedPredicateException(this, "Precpred(_ctx, 1)");
						State = 113; Match(OP_OR);
						State = 114; _localctx.expr2 = preprocessor_expression(2);
						 _localctx.value =  (_localctx.expr1.value == "true" || _localctx.expr2.value == "true" ? "true" : "false"); 
						}
						break;
					}
					} 
				}
				State = 121;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 2: return preprocessor_expression_sempred((Preprocessor_expressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool preprocessor_expression_sempred(Preprocessor_expressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 4);

		case 1: return Precpred(_ctx, 3);

		case 2: return Precpred(_ctx, 2);

		case 3: return Precpred(_ctx, 1);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\xD0}\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2"+
		"\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3"+
		"\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2"+
		"\x5\x2(\n\x2\x3\x2\x3\x2\x5\x2,\n\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3"+
		"\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x5\x2=\n\x2"+
		"\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x5\x2\x44\n\x2\x3\x2\x3\x2\x3\x2\x3\x2"+
		"\x3\x2\x3\x2\x3\x2\x3\x2\x5\x2N\n\x2\x3\x3\x3\x3\x3\x4\x3\x4\x3\x4\x3"+
		"\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4"+
		"\x3\x4\x5\x4\x62\n\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3"+
		"\x4\a\x4x\n\x4\f\x4\xE\x4{\v\x4\x3\x4\x2\x2\x3\x6\x5\x2\x2\x4\x2\x6\x2"+
		"\x2\x3\x3\x3\xCE\xCE\x91\x2M\x3\x2\x2\x2\x4O\x3\x2\x2\x2\x6\x61\x3\x2"+
		"\x2\x2\b\t\a\xC2\x2\x2\t\n\a\xCD\x2\x2\n\v\x5\x4\x3\x2\v\f\b\x2\x1\x2"+
		"\fN\x3\x2\x2\x2\r\xE\a\xC3\x2\x2\xE\xF\a\xCD\x2\x2\xF\x10\x5\x4\x3\x2"+
		"\x10\x11\b\x2\x1\x2\x11N\x3\x2\x2\x2\x12\x13\a+\x2\x2\x13\x14\x5\x6\x4"+
		"\x2\x14\x15\x5\x4\x3\x2\x15\x16\b\x2\x1\x2\x16N\x3\x2\x2\x2\x17\x18\a"+
		"\xC4\x2\x2\x18\x19\x5\x6\x4\x2\x19\x1A\x5\x4\x3\x2\x1A\x1B\b\x2\x1\x2"+
		"\x1BN\x3\x2\x2\x2\x1C\x1D\a\x1F\x2\x2\x1D\x1E\x5\x4\x3\x2\x1E\x1F\b\x2"+
		"\x1\x2\x1FN\x3\x2\x2\x2 !\a\xC5\x2\x2!\"\x5\x4\x3\x2\"#\b\x2\x1\x2#N\x3"+
		"\x2\x2\x2$+\a\xC6\x2\x2%\'\a\xC1\x2\x2&(\aR\x2\x2\'&\x3\x2\x2\x2\'(\x3"+
		"\x2\x2\x2(,\x3\x2\x2\x2),\a\x1B\x2\x2*,\a\xCC\x2\x2+%\x3\x2\x2\x2+)\x3"+
		"\x2\x2\x2+*\x3\x2\x2\x2,-\x3\x2\x2\x2-.\x5\x4\x3\x2./\b\x2\x1\x2/N\x3"+
		"\x2\x2\x2\x30\x31\a\xC7\x2\x2\x31\x32\a\xCF\x2\x2\x32\x33\x5\x4\x3\x2"+
		"\x33\x34\b\x2\x1\x2\x34N\x3\x2\x2\x2\x35\x36\a\xC8\x2\x2\x36\x37\a\xCF"+
		"\x2\x2\x37\x38\x5\x4\x3\x2\x38\x39\b\x2\x1\x2\x39N\x3\x2\x2\x2:<\a\xC9"+
		"\x2\x2;=\a\xCF\x2\x2<;\x3\x2\x2\x2<=\x3\x2\x2\x2=>\x3\x2\x2\x2>?\x5\x4"+
		"\x3\x2?@\b\x2\x1\x2@N\x3\x2\x2\x2\x41\x43\a\xCA\x2\x2\x42\x44\a\xCF\x2"+
		"\x2\x43\x42\x3\x2\x2\x2\x43\x44\x3\x2\x2\x2\x44\x45\x3\x2\x2\x2\x45\x46"+
		"\x5\x4\x3\x2\x46G\b\x2\x1\x2GN\x3\x2\x2\x2HI\a\xCB\x2\x2IJ\a\xCF\x2\x2"+
		"JK\x5\x4\x3\x2KL\b\x2\x1\x2LN\x3\x2\x2\x2M\b\x3\x2\x2\x2M\r\x3\x2\x2\x2"+
		"M\x12\x3\x2\x2\x2M\x17\x3\x2\x2\x2M\x1C\x3\x2\x2\x2M \x3\x2\x2\x2M$\x3"+
		"\x2\x2\x2M\x30\x3\x2\x2\x2M\x35\x3\x2\x2\x2M:\x3\x2\x2\x2M\x41\x3\x2\x2"+
		"\x2MH\x3\x2\x2\x2N\x3\x3\x2\x2\x2OP\t\x2\x2\x2P\x5\x3\x2\x2\x2QR\b\x4"+
		"\x1\x2RS\a\x94\x2\x2ST\x5\x6\x4\aTU\b\x4\x1\x2U\x62\x3\x2\x2\x2VW\aX\x2"+
		"\x2W\x62\b\x4\x1\x2XY\a$\x2\x2Y\x62\b\x4\x1\x2Z[\a\xCD\x2\x2[\x62\b\x4"+
		"\x1\x2\\]\a\x86\x2\x2]^\x5\x6\x4\x2^_\a\x87\x2\x2_`\b\x4\x1\x2`\x62\x3"+
		"\x2\x2\x2\x61Q\x3\x2\x2\x2\x61V\x3\x2\x2\x2\x61X\x3\x2\x2\x2\x61Z\x3\x2"+
		"\x2\x2\x61\\\x3\x2\x2\x2\x62y\x3\x2\x2\x2\x63\x64\f\x6\x2\x2\x64\x65\a"+
		"\xA1\x2\x2\x65\x66\x5\x6\x4\a\x66g\b\x4\x1\x2gx\x3\x2\x2\x2hi\f\x5\x2"+
		"\x2ij\a\xA2\x2\x2jk\x5\x6\x4\x6kl\b\x4\x1\x2lx\x3\x2\x2\x2mn\f\x4\x2\x2"+
		"no\a\x9E\x2\x2op\x5\x6\x4\x5pq\b\x4\x1\x2qx\x3\x2\x2\x2rs\f\x3\x2\x2s"+
		"t\a\x9F\x2\x2tu\x5\x6\x4\x4uv\b\x4\x1\x2vx\x3\x2\x2\x2w\x63\x3\x2\x2\x2"+
		"wh\x3\x2\x2\x2wm\x3\x2\x2\x2wr\x3\x2\x2\x2x{\x3\x2\x2\x2yw\x3\x2\x2\x2"+
		"yz\x3\x2\x2\x2z\a\x3\x2\x2\x2{y\x3\x2\x2\x2\n\'+<\x43M\x61wy";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace ICSharpCode.NRefactory.Rava.Parser
